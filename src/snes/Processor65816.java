/*Java Super Nintendo Emulator "JavaSNES"
* Written and Copyright by Michael Black, 2014  (blackmd@gmail.com)
* 3/2014 - 5/2014
* 
 This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
    
This class emulates a 65816 processor
    
Resources used in development:
    w65c816s.pdf: "W65C816S 8/16-bit Microprocessor", Western Design Center, Sept 13 2010.  http://www.westerndesigncenter.com
    "65816 Reference in SNES Development", eriknoc, 9/11/12.  http://wiki.superfamicom.org/snes/show/65816+Reference
*/

package snes;

import java.util.Scanner;

public class Processor65816 
{
	//registers
	int A,X,Y,S,D,P;	//A is the accumulator. X, Y are general purpose and are used for memory indexing.  S is the stack pointer, P holds the flag values, and D is used as an offset for some memory operations
	int PC;				//the program counter
	int PBR;			//the program bank.  combined with the PC to find the current instruction
	int DBR;			//the data bank.  used as an offset for memory reads and writes.
	//flags.  actual flag values are stored here.  when P is read these are copied into P.
	//CARRY: set on a arithmetic carry
	//ZERO: cleared when an operation produces 0
	//IRQ: determines whether IRQ requests will produce interrupts
	//INDEXFLAG: if clear, memory accesses using A or immediates and most arithmetic instructions will operate using 16-bit values.  if set, 8 bits. 
	//MEMORYFLAG: if clear, memory accesses using X or Y will be 16 bit.  if set, 8 bit.
	//OVERFLOW: set if a signed arithmetic operation goes over or under
	//NEGATIVE: set if a signed arithmetic operation produces a negative result
	//EMULATION: if clear, pretend to be a 6502 processor.  all memory accesses and instructions will run in 8-bits.
	boolean CARRY,ZERO,IRQ,DECIMAL,INDEXFLAG,MEMORYFLAG,OVERFLOW,NEGATIVE,EMULATION;

	//are we currently halted until an interrupt happens?
	boolean waitForInterrupt=false;
	//has an NMI interrupt been requested?
	boolean NMItrigger=false;
	//VCounter position where NMI will go off
	int NMItriggerPosition=0;
	//how many instructions and cycles have run
	long instructionCount=0;
	long cycleCount=0;
	//how many cycles have run since our last video event
	int instructionsUntilEvent=0;
	//print out processor state for debugging?
	boolean doprint=false;
	
	//flag bits: used for setting the P register from the flags
	private static final int CARRYBIT=1,ZEROBIT=2,IRQBIT=4,DECIMALBIT=8,INDEXFLAGBIT=16,MEMORYFLAGBIT=32,OVERFLOWBIT=64,NEGATIVEBIT=128,EMULATIONBIT=256;

	SNES snes;
	public Processor65816(SNES snes)
	{
		this.snes=snes;
	}

	public void reset()
	{
		PBR=0;
		PC=(snes.memory.readByte(0xfffc)&0xff)|((snes.memory.readByte(0xfffd)&0xff)<<8);
		D=0; DBR=0; S=0x1ff;
		P=0; A=0; X=0; Y=0;
		MEMORYFLAG=true;
		EMULATION=true;
		INDEXFLAG=true;
		IRQ=true;
		waitForInterrupt=false;
		NMItrigger=false;
		NMItriggerPosition=0;
		instructionCount=0;
		instructionsUntilEvent=0;
		cycleCount=0;
		updateP();
	}

	//called from main loop to run a single instruction
	public void doAnInstruction()
	{
		//read the opcode and get the registers and memory values 
		decode();
		//figure out which instruction it is and do the computation and writeback
		execute();
		//update the cycle count
		if(snes.cycleAccurate)
//			snes.docycles(1 * ( cycledelay() - 1 ));	//6 cyc per inst, sub 1 because inst includes the fetch
			snes.docycles(cycleDelayMinusMemory());
		instructionCount++;
		if(doprint)
			printState();
		if(snes.doromhack)
		{
			snes.romhack.instructionInfo(opcodeName, mode16, X16, addr);
			addr=-1;
		}
	}
	
	//65816
	
	//read an instruction byte from memory and advance the PC
	//this may be called more than once per instruction depending on how many bytes are in the instruction
	public int fetch()
	{
		int value=snes.memory.readByte(((PBR&0xff)<<16)|(PC&0xffff));
		if(snes.doromhack) snes.romhack.onfetch(((PBR&0xff)<<16)|(PC&0xffff),value);
		PC=(PC+1)&0xffff;
		return value;
	}
	
	//these values are generated by decode and used in execute
	int addr, value, value2, opcode;
	boolean X16,mode16;
	String opcodeName,operandName;
	
	//read the opcode and get the registers and memory values 
	public void decode()
	{
		//get the first byte
		opcode=fetch()&0xff;
		if(snes.doromhack) snes.romhack.firstInstructionByte();

		int low,high,page;
		//figure out whether we're running this as a 16 bit or 8 bit instruction
		X16=false; mode16=false;
		if(!EMULATION && !INDEXFLAG)
			X16=true;
		if(!EMULATION && !MEMORYFLAG)
			mode16=true;
		
		//w65c816s.pdf page 34
		switch(opcode)
		{
		//1. absolute
		case 0x6d: case 0x2d: case 0x0e: case 0x2c: case 0xcd: case 0xce: case 0x4d: case 0xee: case 0x20: case 0xad: case 0x4e: case 0x0d: case 0x2e: case 0x6e: case 0xed: case 0x1c: case 0x0c:
			low=fetch()&0xff;
			high=fetch()&0xff;
			addr=((DBR&0xff)<<16)|(high<<8)|(low);
			operandName=Integer.toHexString(addr);
			value=snes.memory.readByte(addr)&0xff;
			if(mode16) value|=(snes.memory.readByte(addr+1)&0xff)<<8;
//if (instructionCount>=snes.skip)System.out.printf("%x %x %x %x\n", high,low,addr,value);
			break;
		case 0x4c:
			low=fetch()&0xff;
			high=fetch()&0xff;
			addr=((PBR&0xff)<<16)|(high<<8)|(low);
			operandName=Integer.toHexString(addr);
			break;
		case 0xec: case 0xcc: case 0xae: case 0xac:
			low=fetch()&0xff;
			high=fetch()&0xff;
			addr=((DBR&0xff)<<16)|(high<<8)|(low);
			operandName=Integer.toHexString(addr);
			value=snes.memory.readByte(addr)&0xff;
			if(X16) value|=(snes.memory.readByte(addr+1)&0xff)<<8;
//if (instructionCount>=snes.skip)System.out.printf("%x %x %x %x\n", high,low,addr,value);
			break;
		case 0x8c: case 0x8e: case 0x8d: case 0x9c:
			low=fetch()&0xff;
			high=fetch()&0xff;
			addr=((DBR&0xff)<<16)|(high<<8)|(low);
			operandName=Integer.toHexString(addr);
			break;

		//2. accumulator
		case 0x0a: case 0x3a: case 0x1a: case 0x4a: case 0x2a: case 0x6a: case 0x3b: case 0xba: case 0x8a: case 0x9a: case 0x9b: case 0x98: case 0xbb: case 0xcb: case 0xeb: case 0xfb: case 0x42:
			break;

		//3. absolute indexed, x
		case 0x7d: case 0x3d: case 0x5d: case 0xbd: case 0x1d: case 0xfd: case 0xdd: case 0x1e: case 0x3c: case 0xde: case 0xfe: case 0x5e: case 0x3e: case 0x7e:
			low=fetch()&0xff;
			high=fetch()&0xff;
			if(X16)
				addr=(((high<<8)|low)+(X&0xffff))|((DBR&0xff)<<16);
			else
				addr=(((high<<8)|low)+(X&0xff))|((DBR&0xff)<<16);
			operandName="("+Integer.toHexString((high<<8)|low)+",x)";
			value=snes.memory.readByte(addr)&0xff;
			if(mode16) value|=(snes.memory.readByte(addr+1)&0xff)<<8;
			break;
		case 0xbc:
			low=fetch()&0xff;
			high=fetch()&0xff;
			if(X16)
				addr=(((high<<8)|low)+(X&0xffff))|((DBR&0xff)<<16);
			else
				addr=(((high<<8)|low)+(X&0xff))|((DBR&0xff)<<16);
			operandName="("+Integer.toHexString((high<<8)|low)+",x)";
			value=snes.memory.readByte(addr)&0xff;
			if(X16) value|=(snes.memory.readByte(addr+1)&0xff)<<8;
			break;
		case 0x9d: case 0x9e:
			low=fetch()&0xff;
			high=fetch()&0xff;
			operandName="("+Integer.toHexString((high<<8)|low)+",x)";
			if(X16)
				addr=(((high<<8)|low)+(X&0xffff))|((DBR&0xff)<<16);
			else
				addr=(((high<<8)|low)+(X&0xff))|((DBR&0xff)<<16);
//System.out.printf("%x %x %x %x %x\n", high,low,(X&0xffff),(DBR&0xff),addr);
			break;

		//4. absolute indexed, y
		case 0x79: case 0x39: case 0x59: case 0xb9: case 0x19: case 0xf9: case 0xd9:
			low=fetch()&0xff;
			high=fetch()&0xff;
			operandName="("+Integer.toHexString((high<<8)|low)+",y)";
			if(X16)
				addr=(((high<<8)|low)+(Y&0xffff))|((DBR&0xff)<<16);
			else
				addr=(((high<<8)|low)+(Y&0xff))|((DBR&0xff)<<16);
			value=snes.memory.readByte(addr)&0xff;
			if(mode16) value|=(snes.memory.readByte(addr+1)&0xff)<<8;
			break;
		case 0xbe:
			low=fetch()&0xff;
			high=fetch()&0xff;
			operandName="("+Integer.toHexString((high<<8)|low)+",y)";
			if(X16)
				addr=(((high<<8)|low)+(Y&0xffff))|((DBR&0xff)<<16);
			else
				addr=(((high<<8)|low)+(Y&0xff))|((DBR&0xff)<<16);
			value=snes.memory.readByte(addr)&0xff;
			if(X16) value|=(snes.memory.readByte(addr+1)&0xff)<<8;
			break;
		case 0x99:
			low=fetch()&0xff;
			high=fetch()&0xff;
			operandName="("+Integer.toHexString((high<<8)|low)+",y)";
			if(X16)
				addr=(((high<<8)|low)+(Y&0xffff))|((DBR&0xff)<<16);
			else
				addr=(((high<<8)|low)+(Y&0xff))|((DBR&0xff)<<16);
			break;

		//5. absolute long
		case 0x6f: case 0x2f: case 0x4f: case 0xaf: case 0x0f: case 0xef: case 0xcf: case 0x22: case 0x5c:
			low=fetch()&0xff;
			high=fetch()&0xff;
			page=fetch()&0xff;
			addr=(page<<16)|(high<<8)|low;
			operandName=Integer.toHexString(addr);
			value=snes.memory.readByte(addr)&0xff;
			if(mode16) value|=(snes.memory.readByte(addr+1)&0xff)<<8;
//if(instructionCount>=snes.skip) System.out.printf("%x %x %x %x %x\n", low,high,page,addr,value);
			break;
		case 0x8f:
			low=fetch()&0xff;
			high=fetch()&0xff;
			page=fetch()&0xff;
			addr=(page<<16)|(high<<8)|low;
			operandName=Integer.toHexString(addr);
//if(instructionCount>=snes.skip) System.out.printf("%x %x %x %x\n", low,high,page,addr);
	//System.out.printf("%x\n",snes.ppu.WRAM);
			break;

		//6. absolute long indexed, x
		case 0x7f: case 0x3f: case 0x5f: case 0xbf: case 0x1f: case 0xff: case 0xdf:
			low=fetch()&0xff;
			high=fetch()&0xff;
			page=fetch()&0xff;
			addr=(page<<16)|(high<<8)|low;
			if (X16)
				addr=(addr+X)&0xffffff;
			else
				addr=(addr+(X&0xff))&0xffffff;
			value=snes.memory.readByte(addr)&0xff;
			if(mode16) value|=(snes.memory.readByte(addr+1)&0xff)<<8;
			break;
		case 0x9f:
			low=fetch()&0xff;
			high=fetch()&0xff;
			page=fetch()&0xff;
			addr=(page<<16)|(high<<8)|low;
			if (X16)
				addr=(addr+X)&0xffffff;
			else
				addr=(addr+(X&0xff))&0xffffff;
			break;

		//7a. absolute indirect
		case 0x6c:
			low=fetch()&0xff;
			high=fetch()&0xff;
			addr=(high<<8)|low;
			low=snes.memory.readByte(addr)&0xff;
			high=snes.memory.readByte((addr+1)&0xffff)&0xff;
			PC=(high<<8)|low;
			break;
			
		//7b. absolute indirect long
		case 0xdc:
			low=fetch()&0xff;
			high=fetch()&0xff;
			addr=(high<<8)|low;
			low=snes.memory.readByte(addr)&0xff;
			high=snes.memory.readByte((addr+1)&0xffff)&0xff;
			PC=(high<<8)|low;
			PBR=snes.memory.readByte((addr+2)&0xffff)&0xff;
			break;

		//8. absolute indexed indirect
		case 0x7c: case 0xfc:
		//case 0x5d???: typo in data sheet?
			low=fetch()&0xff;
			high=fetch()&0xff;
			addr=((((high<<8)|low)+X)&0xffff)|((PBR&0xff)<<16);
			low=snes.memory.readByte(addr)&0xff;
			high=snes.memory.readByte(addr+1)&0xff;
			addr=(high<<8)|low;
			break;

		//9. direct page
		case 0x65: case 0x25: case 0x06: case 0x24: case 0xc6: case 0x45: case 0xe6: case 0xa5: case 0x46: case 0x05: case 0x26: case 0x66: case 0xe5: case 0xc5: case 0x14: case 0x04:
			low=fetch()&0xff;
			addr=(D+low)&0xffff;
			if ((D&0xff)!=0)
				cycleCount+=(1);
			value=snes.memory.readByte(addr)&0xff;
			if(mode16) value|=(snes.memory.readByte(addr+1)&0xff)<<8;
//if(instructionCount>=snes.skip) {System.out.printf("%d %x %x %x %x\n",instructionCount,low,D,addr,value); }
			break;
		case 0xa6: case 0xa4: 
			low=fetch()&0xff;
			addr=(D+low)&0xffff;
			if ((D&0xff)!=0)
				cycleCount+=(1);
			value=snes.memory.readByte(addr)&0xff;
			if(X16) value|=(snes.memory.readByte(addr+1)&0xff)<<8;
//if(instructionCount>=snes.skip) {System.out.printf("%d %x %x %x %x\n",instructionCount,low,D,addr,value); }
//1610088204 15 0 15 9 / 2f
			break;
		case 0xe4: case 0xc4:
			low=fetch()&0xff;
			addr=(D+low)&0xffff;
			if ((D&0xff)!=0)
				cycleCount+=(1);
			value=snes.memory.readByte(addr)&0xff;
			if(X16) value|=(snes.memory.readByte(addr+1)&0xff)<<8;
			break;
		case 0x85: case 0x64: case 0x84: case 0x86:
			low=fetch()&0xff;
			addr=(D+low)&0xffff;
			if ((D&0xff)!=0)
				cycleCount+=(1);
			break;

		//10. stack relative
		case 0x63: case 0x23: case 0x43: case 0xa3: case 0x03: case 0xe3: case 0xc3:
			low=fetch()&0xff;
			addr=(S+low)&0xffff;
			value=snes.memory.readByte(addr)&0xff;
			if(mode16) value|=(snes.memory.readByte(addr+1)&0xff)<<8;
			break;
		case 0x83:
			low=fetch()&0xff;
			addr=(S+low)&0xffff;
			break;
			
		//11. dp indexed, x
		case 0x75: case 0x35: case 0x16: case 0x34: case 0x55: case 0xf6: case 0xb5: case 0x56: case 0x15: case 0x36: case 0x76: case 0xf5: case 0xd5: case 0xd6:
			low=fetch()&0xff;
			addr=(D+low)&0xffff;
			if(X16)
				addr=(X+addr)&0xffffff;
			else
				addr=((X&0xff)+addr)&0xffffff;
//			if(EMULATION) addr&=0xff;
			value=snes.memory.readByte(addr)&0xff;
			if(mode16) value|=(snes.memory.readByte(addr+1)&0xff)<<8;
			break;
		case 0xb4:
			low=fetch()&0xff;
			addr=(D+low)&0xffff;
			if(X16)
				addr=(X+addr)&0xffffff;
			else
				addr=((X&0xff)+addr)&0xffffff;
//			if(EMULATION) addr&=0xff;
			value=snes.memory.readByte(addr)&0xff;
			if(X16) value|=(snes.memory.readByte(addr+1)&0xff)<<8;
			break;
		case 0x94: case 0x95: case 0x74:
			low=fetch()&0xff;
			addr=(D+low)&0xffff;
			if(X16)
				addr=(X+addr)&0xffffff;
			else
//				addr=((X&0xff)+addr)&0xff;
				addr=((X&0xff)+addr)&0xffffff;
//			if(EMULATION)
//				addr=addr&0xff;
//TODO: IS THIS RIGHT?
			break;

		//12. dp indexed, y
		case 0xb6:
			low=fetch()&0xff;
			addr=(D+low)&0xffff;
			if(X16)
				addr=(Y+addr)&0xffffff;
			else
				addr=((Y&0xff)+addr)&0xffffff;
//			if(EMULATION)
//				addr&=0xff;
			value=snes.memory.readByte(addr)&0xff;
			if(X16) value|=(snes.memory.readByte(addr+1)&0xff)<<8;
			break;
		case 0x96:
			low=fetch()&0xff;
			addr=(D+low)&0xffff;
			if(X16)
				addr=(Y+addr)&0xffffff;
			else
				addr=((Y&0xff)+addr)&0xffffff;
			break;

		//13. direct indirect
		case 0x72: case 0x32: case 0x52: case 0xd2: case 0xb2: case 0x12: case 0xf2:
			low=fetch()&0xff;
			addr=((D+low)&0xffff);
			low=snes.memory.readByte(addr)&0xff;
			high=snes.memory.readByte((addr+1)&0xffff)&0xff;
			addr=((DBR&0xff)<<16)|(high<<8)|low;
			value=snes.memory.readByte(addr)&0xff;
			if(mode16) value|=(snes.memory.readByte(addr+1)&0xff)<<8;
			break;
		case 0x92:
			low=fetch()&0xff;
			addr=((D+low)&0xffff);
			low=snes.memory.readByte(addr)&0xff;
			high=snes.memory.readByte((addr+1)&0xffff)&0xff;
			addr=((DBR&0xff)<<16)|(high<<8)|low;
			break;

		//14. dp indirect long
		case 0x67: case 0x27: case 0x47: case 0xa7: case 0x07: case 0xe7: case 0xc7:
			low=fetch()&0xff;
			addr=((D+low)&0xffff);
			low=snes.memory.readByte(addr)&0xff;
			high=snes.memory.readByte((addr+1)&0xffff)&0xff;
			page=snes.memory.readByte((addr+2)&0xffff)&0xff;
			addr=(page<<16)|(high<<8)|low;
			value=snes.memory.readByte(addr)&0xff;
			if(mode16) value|=(snes.memory.readByte(addr+1)&0xff)<<8;
			break;
		case 0x87:
			low=fetch()&0xff;
			addr=((D+low)&0xffff);
			low=snes.memory.readByte(addr)&0xff;
			high=snes.memory.readByte((addr+1)&0xffff)&0xff;
			page=snes.memory.readByte((addr+2)&0xffff)&0xff;
			addr=(page<<16)|(high<<8)|low;
			break;

		//15. stack relative indexed indirect, y
		case 0x73: case 0x33: case 0x53: case 0xb3: case 0x13: case 0xf3: case 0xd3:
			low=fetch()&0xff;
			addr=(low+S)&0xffff;
			low=snes.memory.readByte(addr)&0xff;
			high=snes.memory.readByte((addr+1)&0xffff)&0xff;
			addr=((DBR&0xff)<<16)|(high<<8)|low;
			if(X16)
				addr=(addr+Y)&0xffffff;
			else
				addr=(addr+(Y&0xff))&0xffffff;
			value=snes.memory.readByte(addr)&0xff;
			if(mode16) value|=(snes.memory.readByte(addr+1)&0xff)<<8;
			break;
		case 0x93:
			low=fetch()&0xff;
			addr=(low+S)&0xffff;
			low=snes.memory.readByte(addr)&0xff;
			high=snes.memory.readByte((addr+1)&0xffff)&0xff;
			addr=((DBR&0xff)<<16)|(high<<8)|low;
			if(X16)
				addr=(addr+Y)&0xffffff;
			else
				addr=(addr+(Y&0xff))&0xffffff;
			break;
			
		//16. direct indexed indirect, x
		case 0x61: case 0x21: case 0x41: case 0xa1: case 0x01: case 0xe1: case 0xc1:
			low=fetch()&0xff;
			if(X16)
				addr=(low+D+X)&0xffff;
			else
				addr=(low+D+(X&0xff))&0xffff;
//TODO: changed ff to ffff: verify this
			low=snes.memory.readByte(addr)&0xff;
			high=snes.memory.readByte((addr+1)&0xffff)&0xff;
			addr=((DBR&0xff)<<16)|(high<<8)|low;
			value=snes.memory.readByte(addr)&0xff;
			if(mode16) value|=(snes.memory.readByte(addr+1)&0xff)<<8;
			break;
		case 0x81:
			low=fetch()&0xff;
			if(X16)
				addr=(low+D+X)&0xffff;
			else
				addr=(low+D+(X&0xff))&0xffff;
			low=snes.memory.readByte(addr)&0xff;
			high=snes.memory.readByte((addr+1)&0xffff)&0xff;
			addr=((DBR&0xff)<<16)|(high<<8)|low;
			break;

		//17. direct indirect indexed, y
		case 0x71: case 0x31: case 0x51: case 0xb1: case 0x11: case 0xf1: case 0xd1:
			low=fetch()&0xff;
			addr=(low+D)&0xffff;
			low=snes.memory.readByte(addr)&0xff;
			high=snes.memory.readByte((addr+1)&0xffff)&0xff;
			addr=((DBR&0xff)<<16)|(high<<8)|low;
			if(X16)
				addr=(addr+Y)&0xffffff;
			else
				addr=(addr+(Y&0xff))&0xffffff;
			value=snes.memory.readByte(addr)&0xff;
			if(mode16) value|=(snes.memory.readByte(addr+1)&0xff)<<8;
			break;
		case 0x91:
			low=fetch()&0xff;
			addr=(low+D)&0xffff;
			low=snes.memory.readByte(addr)&0xff;
			high=snes.memory.readByte((addr+1)&0xffff)&0xff;
			addr=((DBR&0xff)<<16)|(high<<8)|low;
			if(X16)
				addr=(addr+Y)&0xffffff;
			else
				addr=(addr+(Y&0xff))&0xffffff;
			break;

		//18. direct indirect long indexed, y
		case 0x17: case 0x77: case 0x37: case 0x57: case 0xb7: case 0xf7: case 0xd7:
			low=fetch()&0xff;
			addr=(low+D)&0xffff;
//if(instructionCount>=snes.skip)System.out.printf("%x %x ", low,addr);
			low=snes.memory.readByte(addr)&0xff;
			high=snes.memory.readByte((addr+1)&0xffff)&0xff;
			page=snes.memory.readByte((addr+2)&0xffff)&0xff;
			addr=(page<<16)|(high<<8)|low;
//if(instructionCount>=snes.skip)System.out.printf("%x\n", addr);
			if(X16)
				addr=(addr+Y)&0xffffff;
			else
				addr=(addr+(Y&0xff))&0xffffff;
			value=snes.memory.readByte(addr)&0xff;
			if(mode16) value|=(snes.memory.readByte(addr+1)&0xff)<<8;
			break;
		case 0x97:
			low=fetch()&0xff;
			addr=(low+D)&0xffff;
//if(instructionCount>=snes.skip)System.out.printf("97store %x %x ", low,addr);
			low=snes.memory.readByte(addr)&0xff;
			high=snes.memory.readByte((addr+1)&0xffff)&0xff;
			page=snes.memory.readByte((addr+2)&0xffff)&0xff;
			addr=(page<<16)|(high<<8)|low;
//if(instructionCount>=snes.skip)System.out.printf("%x ", addr);
			if(X16)
				addr=(addr+Y)&0xffffff;
			else
				addr=(addr+(Y&0xff))&0xffffff;
//if(instructionCount>=snes.skip)System.out.printf("%x\n", addr);
			break;

		//19. implied
		case 0x18: case 0xd8: case 0x58: case 0xb8: case 0xca: case 0x88: case 0xe8: case 0xc8: case 0xea: case 0x38: case 0xf8: case 0x78: case 0xdb: case 0xaa: case 0xa8: case 0x5b: case 0x1b: case 0x7b: 
			break;

		//20. program counter relative
		case 0x90: case 0xb0: case 0xf0: case 0x30: case 0xd0: case 0x10: case 0x80: case 0x50: case 0x70:
			addr=fetch();
			addr=(addr+PC)&0xffff;
			break;

		//21. program counter relative long
		case 0x82:
//			low=fetch();
//			high=fetch();
//			addr=(high*256+low+PC)&0xffff;
			
			low=fetch()&0xff;
			high=fetch()&0xff;
			addr=(((high<<8)|low)+PC)&0xffff;
			break;

		//23. block move
		case 0x54: case 0x44:
//UNSIGNING
//			value=fetch();
//			value2=fetch();
			value=fetch()&0xff;
			value2=fetch()&0xff;
			break;
			
		//24. immediate
		case 0x69: case 0x29: case 0x49: case 0xa9: case 0x09: case 0xe9: case 0x89: case 0xc9:
			value=fetch()&0xff;
			if (mode16)
				value=(value&0xff)|((fetch()&0xff)<<8);
			break;
			
		case 0xc2: case 0xe2:
//UNSIGNING
			value=fetch()&0xff;
			break;
		
		case 0xe0: case 0xc0: case 0xa2: case 0xa0:
			value=fetch()&0xff;
			if (X16)
				value=(value&0xff)|((fetch()&0xff)<<8);
			break;
			
		//22a. stack/interrupt
		case 0x00: case 0x02:
			break;
			
		//22b. stack absolute
		case 0xf4:
			low=fetch()&0xff;
			high=fetch()&0xff;
			addr=((DBR&0xff)<<16)|(high<<8)|(low);
			break;
			
		//22c. stack dp indirect
		case 0xd4:
//UNSIGNING
//			low=fetch();
			low=fetch()&0xff;
			addr=(D+low)&0xffff;
			break;
			
		//22d. stack pc relative long
		case 0x62:
			low=fetch()&0xff;
			high=fetch()&0xff;
			addr=(high*256+low+PC)&0xffff;
			break;
			
		//22e. stack push
		case 0x48: case 0x8b: case 0x0b: case 0x4b: case 0x08: case 0xda: case 0x5a:
			break;
			
		//22f. stack pull
		case 0x68: case 0xab: case 0x2b: case 0x28: case 0xfa: case 0x7a:
			break;
			
		//22g. stack rti
		case 0x40:
			break;
			
		//22h. stack rtl
		case 0x6b:
			break;
			
		//22i. stack rts
		case 0x60:
			break;

		default:
			fault("Unrecognized opcode in decode: "+opcode);
			break;

		}
	}
	
	//figure out which instruction it is and do the computation and writeback
	public void execute()
	{
		int result=0;
		int srcaddr,destaddr;
		opcodeName="";
		
		switch(opcode)
		{
		//add with carry: add two numbers and the carry flag
		case 0x61: case 0x63: case 0x65: case 0x67: case 0x69: case 0x6d: case 0x6f: case 0x71: case 0x72: case 0x73: case 0x75: case 0x77: case 0x79: case 0x7d: case 0x7f:
			opcodeName="ADC";
			if(mode16)
				ADC16(value);
			else
				ADC8(value);
			break;
		//bitwise logical AND
		case 0x21: case 0x23: case 0x25: case 0x27: case 0x29: case 0x2d: case 0x2f: case 0x31: case 0x32: case 0x33: case 0x35: case 0x37: case 0x39: case 0x3d: case 0x3f:
			opcodeName="AND";
			if(mode16)
				AND16(value);
			else
				AND8(value);
			break;
		//arithmetic shift left: move all bits left
		//do it on memory
		case 0x06: case 0x0e: case 0x16: case 0x1e:
			opcodeName="ASL";
			if(mode16)
			{
				result=ASL16(value);
				snes.memory.writeByte(addr, (byte)(result&0xff));
				snes.memory.writeByte(addr+1, (byte)((result&0xff00)>>8));
			}
			else
			{
				result=ASL8(value);
				snes.memory.writeByte(addr, (byte)result);
			}
			break;
		//do it on A
		case 0x0a:
			opcodeName="ASL";
			if(mode16)
				A=ASL16(A)&0xffff;
			else
				A=(A&~0xff)|(ASL8(A&0xff)&0xff);
			break;
		//do a bitwise AND, set the zero flag, throw away the result
		case 0x24: case 0x2c: case 0x34: case 0x3c:
			opcodeName="BIT";
			if (mode16)
				BIT16(value);
			else
				BIT8(value);
			break;
		case 0x89:
			opcodeName="BIT";
			if(mode16)
				ZERO=((A&value)==0);
			else
				ZERO=(((A&0xff)&(value&0xff))==0);
			break;
		//branch if carry is clear
		case 0x90:
			opcodeName="BCC";
			BCC(addr);
			break;
		//branch if carry is set
		case 0xb0:
			opcodeName="BCS";
			BCS(addr);
			break;
		//branch on ZERO
		case 0xf0:
			opcodeName="BEQ";
			BEQ(addr);
			break;
		//branch on not zero
		case 0xd0:
			opcodeName="BNE";
			BNE(addr);
			break;
		//branch on positive
		case 0x10:
			opcodeName="BPL";
			BPL(addr);
			break;
		//branch on negative
		case 0x30:
			opcodeName="BMI";
			BMI(addr);
			break;
		//branch on overflow
		case 0x70:
			opcodeName="BVS";
			BVS(addr);
			break;
		//branch on not overflow
		case 0x50:
			opcodeName="BVC";
			BVC(addr);
			break;
		//branch unconditionally
		case 0x80:
			opcodeName="BRA";
			BRA(addr);
			break;
		//branch to an absolute 24-bit address
		case 0x82:
			opcodeName="BRL";
			BRL(addr);
			break;
		//break: stop executing instructions until an interrupt happens
		case 0x00:
			opcodeName="BRK";
			BRK();
			break;
		//clear carry
		case 0x18:
			opcodeName="CLC";
			CARRY=false;
			break;
		//clear (enable) IRQs
		case 0x58:
			opcodeName="CLI";
			IRQ=false;
			break;
		//clear decimal
		case 0xd8:
			opcodeName="CLD";
			DECIMAL=false;
			break;
		//clear overflow
		case 0xb8:
			opcodeName="CLV";
			OVERFLOW=false;
			break;
		//do a subtraction, update flags, throw away result
		case 0xc1: case 0xc3: case 0xc5: case 0xc7: case 0xc9: case 0xcd: case 0xcf: case 0xd1: case 0xd2: case 0xd3: case 0xd5: case 0xd7: case 0xd9: case 0xdd: case 0xdf:
			opcodeName="CMP";
			if(mode16)
				CMP16(value);
			else
				CMP8(value);
			break;
		//do it using X
		case 0xe0: case 0xe4: case 0xec:
			opcodeName="CPX";
			if(X16)
				CPX16(value);
			else
				CPX8(value);
			break;
		//do it using Y
		case 0xc0: case 0xc4: case 0xcc:
//System.out.printf("CPY %x %x",addr,value);
			opcodeName="CPY";
			if(X16)
				CPY16(value);
			else
				CPY8(value);
			break;
		//call a co-processor.  SNES doesn't have a co-processor, however, so just break.
		case 0x02:
			opcodeName="COP";
			COP();
			break;
		//decrement memory
		case 0xc6: case 0xce: case 0xd6: case 0xde:
			opcodeName="DEC";
			if(mode16)
			{
				result=DEC16(value);
				snes.memory.writeByte(addr, (byte)(result&0xff));
				snes.memory.writeByte(addr+1, (byte)((result&0xff00)>>8));
			}
			else
			{
				result=DEC8(value);
				snes.memory.writeByte(addr, (byte)result);
			}

			break;
		//decrement A
		case 0x3a:
			opcodeName="DEA";
			if(mode16)
				DEA16();
			else
				DEA8();
			break;
		//decrement X
		case 0xca:
			opcodeName="DEX";
			if(X16)
				DEX16();
			else
				DEX8();
			break;
		//decrement Y
		case 0x88:
			opcodeName="DEY";
			if(X16)
				DEY16();
			else
				DEY8();
			break;
		//increment memory
		case 0xe6: case 0xee: case 0xf6: case 0xfe:
			opcodeName="INC";
			if(mode16)
			{
				result=INC16(value);
				snes.memory.writeByte(addr, (byte)(result&0xff));
				snes.memory.writeByte(addr+1, (byte)((result&0xff00)>>8));
			}
			else
			{
				result=INC8(value);
				snes.memory.writeByte(addr, (byte)result);
			}
			break;
		//increment A
		case 0x1a:
			opcodeName="INA";
			if(mode16)
				INA16();
			else
				INA8();
			break;
		//increment X
		case 0xe8:
			opcodeName="INX";
			if(X16)
				INX16();
			else
				INX8();
			break;
		//increment Y
		case 0xc8:
			opcodeName="INY";
			if(X16)
				INY16();
			else
				INY8();
			break;
		//bitwise XOR
		case 0x41: case 0x43: case 0x45: case 0x47: case 0x49: case 0x4d: case 0x4f: case 0x51: case 0x52: case 0x53: case 0x55: case 0x57: case 0x59: case 0x5d: case 0x5f:
			opcodeName="EOR";
			if(mode16)
				EOR16(value);
			else
				EOR8(value);
			break;
		//unconditional absolute branch
		case 0x4c:
			opcodeName="JMP";
			PC=addr&0xffff;
			PBR=(addr>>16)&0xff;
			break;			
		case 0x7c:
			opcodeName="JMP";
			PC=addr;
			break;
		case 0x6c:
			opcodeName="JMP";
			break;
		case 0x5c:
			opcodeName="JMP";
			PC=addr&0xffff;
			PBR=(addr>>16)&0xff;
			break;
		case 0xdc:
			opcodeName="JMP";
			break;
		//subroutine call: branch but push return address on the stack
		case 0x20:
			opcodeName="JSR";
			if(EMULATION)
				PUSHW8((PC-1)&0xffff);
			else
				PUSHW16((PC-1)&0xffff);
			PC=addr&0xffff;
			break;
		case 0xfc:
			opcodeName="JSR";
			PUSHW16((PC-1)&0xffff);
			if(EMULATION)
				S=0x100|(S&0xff);
			PC=addr&0xffff;
			break;
		case 0x22:
			opcodeName="JSR";
			PUSHB16(PBR);
			PUSHW16((PC-1)&0xffff);
			if(EMULATION)
				S=0x100|(S&0xff);
			PC=addr&0xffff;
			PBR=(addr>>16)&0xff;
			break;			
		//load a value into A
		case 0xa1: case 0xa3: case 0xa5: case 0xa7: case 0xa9: case 0xad: case 0xaf: case 0xb1: case 0xb2: case 0xb3: case 0xb5: case 0xb7: case 0xb9: case 0xbd: case 0xbf:
			opcodeName="LDA";
//if(instructionCount>=snes.skip) {System.out.printf("%d %x %x\n",instructionCount,addr,value); }
			if(mode16)
				LDA16(value);
			else
				LDA8(value);
			break;
		//load a value into X
		case 0xa2: case 0xa6: case 0xae: case 0xb6: case 0xbe:
			opcodeName="LDX";
//System.out.printf("%d %x %x\n",instructionCount,addr,value);
			if(X16)
				LDX16(value);
			else
				LDX8(value);
			break;
		//load a value into Y
		case 0xa0: case 0xa4: case 0xac: case 0xb4: case 0xbc:
			opcodeName="LDY";
			if(X16)
				LDY16(value);
			else
				LDY8(value);
			break;
		//logical shift right
		case 0x46: case 0x4e: case 0x56: case 0x5e:
			opcodeName="LSR";
			if(mode16)
			{
				result=LSR16(value);
				snes.memory.writeByte(addr, (byte)(result&0xff));
				snes.memory.writeByte(addr+1, (byte)((result&0xff00)>>8));
			}
			else
			{
				result=LSR8(value);
				snes.memory.writeByte(addr, (byte)result);
			}
			break;
		case 0x4a:
			opcodeName="LSR";
			if(mode16)
				A=LSR16(A)&0xffff;
			else
				A=(A&~0xff)|(LSR8(A&0xff)&0xff);
			break;
		//move a block of data, starting from bottom
		case 0x54:
			opcodeName="MVN";
			DBR=value;
			srcaddr=((value2&0xff)<<16)|(X&0xffff);
			destaddr=((DBR&0xff)<<16)|(Y&0xffff);
			snes.memory.writeByte(destaddr, snes.memory.readByte(srcaddr));
			if (X16)
			{
				X=(X+1)&0xffff;
				Y=(Y+1)&0xffff;
			}
			else
			{
				X=(X+1)&0xff;
				Y=(Y+1)&0xff;
			}
			A=(A-1)&0xffff;
			//repeat instruction if A's not 0
			if(A!=0xffff)
				PC=(PC-3)&0xffff;
			break;
		//move a block of data, starting from the top
		case 0x44:
			opcodeName="MVP";
			DBR=value;
			srcaddr=((value2&0xff)<<16)|(X&0xffff);
			destaddr=((DBR&0xff)<<16)|(Y&0xffff);
			snes.memory.writeByte(destaddr, snes.memory.readByte(srcaddr));
			if (X16)
			{
				X=(X-1)&0xffff;
				Y=(Y-1)&0xffff;
			}
			else
			{
				X=(X-1)&0xff;
				Y=(Y-1)&0xff;
			}
			A=(A-1)&0xffff;
			//repeat instruction if A's not 0
			if(A!=0xffff)
				PC=(PC-3)&0xffff;
			break;
		//do nothing
		case 0xea:
			opcodeName="NOP";
			break;
		//bitwise logical OR
		case 0x01: case 0x03: case 0x05: case 0x07: case 0x09: case 0x0d: case 0x0f: case 0x11: case 0x12: case 0x13: case 0x15: case 0x17: case 0x19: case 0x1d: case 0x1f:
			opcodeName="ORA";
			if(mode16)
				OR16(value);
			else
				OR8(value);
			break;
		//push immediate or an address
		case 0xf4:
			opcodeName="PEA";
			PUSHW16(addr);
			if (EMULATION)
				S=0x100|(S&0xff);
			break;
		case 0xd4:
			opcodeName="PEI";
			PUSHW16(addr);
			if (EMULATION)
				S=0x100|(S&0xff);
			break;
		case 0x62:
			opcodeName="PER";
			PUSHW16(addr);
			if (EMULATION)
				S=0x100|(S&0xff);
			break;
		//push A
		case 0x48:
			opcodeName="PHA";
			if (EMULATION)
				PUSHB8(A&0xff);
			else if (!mode16)
				PUSHB16(A&0xff);
			else
				PUSHW16(A);
			break;
		//push DBR
		case 0x8b:
			opcodeName="PHB";
			if (EMULATION)
				PUSHB8(DBR&0xff);
			else
				PUSHB16(DBR&0xff);
			break;
		//push D
		case 0x0b:
			opcodeName="PHD";
			PUSHW16(D);
			if (EMULATION)
				S=0x100|(S&0xff);
			break;
		//push PBR
		case 0x4b:
			opcodeName="PHK";
			if (EMULATION)
				PUSHB8(PBR&0xff);
			else
				PUSHB16(PBR&0xff);
			break;
		//push flags
		case 0x08:
			opcodeName="PHP";
			updateP();
			if (EMULATION)
				PUSHB8(P&0xff);
			else
				PUSHB16(P&0xff);
			break;
		//push X
		case 0xda:
			opcodeName="PHX";
			if (EMULATION)
				PUSHB8(X&0xff);
			else if (!X16)
				PUSHB16(X&0xff);
			else
				PUSHW16(X);
			break;
		//push Y
		case 0x5a:
			opcodeName="PHY";
			if (EMULATION)
				PUSHB8(Y&0xff);
			else if (!X16)
				PUSHB16(Y&0xff);
			else
				PUSHW16(Y);
			break;
		//pop A
		case 0x68:
			opcodeName="PLA";
			if (EMULATION)
			{
				A=(A&0xff00)|(PULLB8()&0xff);
				ZERO= ((A&0xff)==0);
				NEGATIVE= ((A&0x80)!=0);
			}
			else if (!mode16)
			{
				A=(A&0xff00)|(PULLB16()&0xff);
				ZERO= ((A&0xff)==0);
				NEGATIVE= ((A&0x80)!=0);
			}
			else
			{
				A=PULLW16();
				ZERO= ((A&0xffff)==0);
				NEGATIVE= ((A&0x8000)!=0);
			}
			break;
		//pop DBR
		case 0xab:
			opcodeName="PLB";
			if (EMULATION)
				DBR=PULLB8();
			else
				DBR=PULLB16();
			ZERO= ((DBR&0xff)==0);
			NEGATIVE= ((DBR&0x80)!=0);
			break;
		//pop D
		case 0x2b:
			opcodeName="PLD";
			D=PULLW16();
			ZERO= ((D&0xffff)==0);
			NEGATIVE= ((D&0x8000)!=0);
			if (EMULATION)
				S=0x100|(S&0xff);
			break;
		//pop flags
		case 0x28:
			opcodeName="PLP";
			updateP();
			if (EMULATION)
			{
				P=(P&0xff00)|(PULLB8()&0xff);
				updateFlagsFromP();
				MEMORYFLAG=true;
				INDEXFLAG=true;
			}
			else
			{
				P=(P&0xff00)|(PULLB16()&0xff);
				updateFlagsFromP();
			}
			if (INDEXFLAG)
			{
				Y=Y&0xff;
				X=X&0xff;
			}
			break;
		//pop X
		case 0xfa:
			opcodeName="PLX";
			if (EMULATION)
			{
				X=(X&0xff00)|(PULLB8()&0xff);
				ZERO= ((X&0xff)==0);
				NEGATIVE= ((X&0x80)!=0);
			}
			else if (!X16)
			{
				X=(X&0xff00)|(PULLB16()&0xff);
				ZERO= ((X&0xff)==0);
				NEGATIVE= ((X&0x80)!=0);
			}
			else
			{
				X=PULLW16();
				ZERO= ((X&0xffff)==0);
				NEGATIVE= ((X&0x8000)!=0);
			}
			break;
		//pop Y
		case 0x7a:
			opcodeName="PLY";
			if (EMULATION)
			{
				Y=(Y&0xff00)|(PULLB8()&0xff);
				ZERO= ((Y&0xff)==0);
				NEGATIVE= ((Y&0x80)!=0);
			}
			else if (!X16)
			{
				Y=(Y&0xff00)|(PULLB16()&0xff);
				ZERO= ((Y&0xff)==0);
				NEGATIVE= ((Y&0x80)!=0);
			}
			else
			{
				Y=PULLW16();
				ZERO= ((Y&0xffff)==0);
				NEGATIVE= ((Y&0x8000)!=0);
			}
			break;
		//reset the flags specified by value
		case 0xc2:
			opcodeName="REP";
			updateP();
			P=(P&0xff00)|(P&((~value)&0xff));
			updateFlagsFromP();
			if(EMULATION)
			{
				INDEXFLAG=true;
				MEMORYFLAG=true;
			}
			if(INDEXFLAG)
			{
				X&=0xff;
				Y&=0xff;
			}
			break;
		//rotate left
		case 0x26: case 0x2e: case 0x36: case 0x3e:
			opcodeName="ROL";
			if(mode16)
			{
				result=ROL16(value);
				snes.memory.writeByte(addr, (byte)(result&0xff));
				snes.memory.writeByte(addr+1, (byte)((result&0xff00)>>8));
			}
			else
			{
				result=ROL8(value);
				snes.memory.writeByte(addr, (byte)result);
			}
			break;
		case 0x2a:
			opcodeName="ROL";
			if(mode16)
				A=ROL16(A)&0xffff;
			else
				A=(A&~0xff)|(ROL8(A&0xff)&0xff);
			break;
		//rotate right
		case 0x66: case 0x6e: case 0x76: case 0x7e:
			opcodeName="ROR";
			if(mode16)
			{
				result=ROR16(value);
				snes.memory.writeByte(addr, (byte)(result&0xff));
				snes.memory.writeByte(addr+1, (byte)((result&0xff00)>>8));
			}
			else
			{
				result=ROR8(value);
				snes.memory.writeByte(addr, (byte)result);
			}
			break;
		case 0x6a:
			opcodeName="ROR";
			if(mode16)
				A=ROR16(A)&0xffff;
			else
				A=(A&~0xff)|(ROR8(A&0xff)&0xff);
			break;
		//return from an interrupt: pop the flags, PC and PBR
		case 0x40:
			opcodeName="RTI";
			updateP();
			if (!EMULATION)
			{
				P=(P&0xff00)|(PULLB16()&0xff);
				updateFlagsFromP();
				PC=PULLW16();
				PBR=PULLB16();
			}
			else
			{
				P=(P&0xff00)|(PULLB8()&0xff);
				updateFlagsFromP();
				PC=PULLW8();
				MEMORYFLAG=true;
				INDEXFLAG=true;
			}
			if (INDEXFLAG)
			{
				X=X&0xff;
				Y=Y&0xff;
			}
			break;
		//return from a long call: pop PC and PBR
		case 0x6b:
			opcodeName="RTL";
			PC=PULLW16()&0xffff;
			PBR=PULLB16()&0xff;
			if(EMULATION)
				S=0x100|(S&0xff);
			PC=(PC+1)&0xffff;
			break;
		//return from a short call: just pop PC
		case 0x60:
			opcodeName="RTS";
			if (EMULATION)
				PC=PULLW8()&0xffff;
			else
				PC=PULLW16()&0xffff;
			PC=(PC+1)&0xffff;
			break;
		//subtract with carry
		case 0xe1: case 0xe3: case 0xe5: case 0xe7: case 0xe9: case 0xed: case 0xef: case 0xf1: case 0xf2: case 0xf3: case 0xf5: case 0xf7: case 0xf9: case 0xfd: case 0xff:
			opcodeName="SBC";
			if(mode16)
				SBC16(value);
			else
				SBC8(value);
			break;
		//set carry
		case 0x38:
			opcodeName="SEC";
			CARRY=true;
			break;
		//set (disable) IRQ
		case 0x78:
			opcodeName="SEI";
			IRQ=true;
			break;
		//set D
		case 0xf8:
			opcodeName="SED";
			DECIMAL=true;
			break;
		//set flags from value
		case 0xe2:
			opcodeName="SEP";
			updateP();
			P=(P&0xff00)|(P|(value&0xff));
			updateFlagsFromP();
			if(EMULATION)
			{
				INDEXFLAG=true;
				MEMORYFLAG=true;
			}
			if(INDEXFLAG)
			{
				X&=0xff;
				Y&=0xff;
			}
			break;
		//store A
		case 0x81: case 0x83: case 0x85: case 0x87: case 0x8d: case 0x8f: case 0x91: case 0x92: case 0x93: case 0x95: case 0x97: case 0x99: case 0x9d: case 0x9f:
			opcodeName="STA";
			if(mode16)
			{
				result=STA16();
				snes.memory.writeByte(addr, (byte)(result&0xff));
				snes.memory.writeByte(addr+1, (byte)((result>>8)&0xff));
			}
			else
			{
				result=STA8();
				snes.memory.writeByte(addr, (byte)result);
			}
			break;
		//store X
		case 0x86: case 0x8e: case 0x96:
			opcodeName="STX";
			if(X16)
			{
				result=STX16();
				snes.memory.writeByte(addr, (byte)(result&0xff));
				snes.memory.writeByte(addr+1, (byte)((result>>8)&0xff));
			}
			else
			{
				result=STX8();
				snes.memory.writeByte(addr, (byte)result);
			}
			break;
		//store Y
		case 0x84: case 0x8c: case 0x94:
			opcodeName="STY";
			if(X16)
			{
				result=STY16();
				snes.memory.writeByte(addr, (byte)(result&0xff));
				snes.memory.writeByte(addr+1, (byte)((result>>8)&0xff));
			}
			else
			{
				result=STY8();
				snes.memory.writeByte(addr, (byte)result);
			}
			break;
		//store a 0 value
		case 0x64: case 0x74: case 0x9c: case 0x9e:
			opcodeName="STZ";
			if (mode16)
			{
				result=STZ();
				snes.memory.writeByte(addr, (byte)(result&0xff));
				snes.memory.writeByte(addr+1, (byte)((result>>8)&0xff));
			}
			else
			{
				result=STZ();
				snes.memory.writeByte(addr, (byte)result);				
			}
			break;
		//test and reset bits
		case 0x14: case 0x1c:
			opcodeName="TRB";
			if(mode16)
			{
				result=TRB16(value);
				snes.memory.writeByte(addr, (byte)(result&0xff));
				snes.memory.writeByte(addr+1, (byte)((result&0xff00)>>8));
			}
			else
			{
				result=TRB8(value);
				snes.memory.writeByte(addr, (byte)result);
			}
			break;
		//test and set bits
		case 0x04: case 0x0c:
			opcodeName="TSB";
			if(mode16)
			{
				result=TSB16(value);
				snes.memory.writeByte(addr, (byte)(result&0xff));
				snes.memory.writeByte(addr+1, (byte)((result&0xff00)>>8));
			}
			else
			{
				result=TSB8(value);
				snes.memory.writeByte(addr, (byte)result);
			}
			break;
		//copy A to X
		case 0xaa:
			opcodeName="TAX";
			TAX();
			break;
		//copy A to Y
		case 0xa8:
			opcodeName="TAY";
			TAY();
			break;
		//copy A to D
		case 0x5b:
			opcodeName="TCD";
			TCD();
			break;
		//copy A to stack pointer
		case 0x1b:
			opcodeName="TCS";
			TCS();
			break;
		//copy D to A
		case 0x7b:
			opcodeName="TDC";
			TDC();
			break;
		//copy stack pointer to A
		case 0x3b:
			opcodeName="TSC";
			TSC();
			break;
		//copy stack pointer to X
		case 0xba:
			opcodeName="TSX";
			TSX();
			break;
		//copy X to A
		case 0x8a:
			opcodeName="TXA";
			TXA();
			break;
		//copy X to stack pointer
		case 0x9a:
			opcodeName="TXS";
			TXS();
			break;
		//copy X to Y
		case 0x9b:
			opcodeName="TXY";
			TXY();
			break;
		//copy Y to A
		case 0x98:
			opcodeName="TYA";
			TYA();
			break;
		//copy Y to X
		case 0xbb:
			opcodeName="TYX";
			TYX();
			break;
		//stop execution until an interrupt happens
		case 0xcb:
			opcodeName="WAI";
			PC=(PC-1)&0xffff;
			waitForInterrupt=true;
			break;
		//if A is 16 bits, swap the upper and lower 8 bits
		case 0xeb:
			opcodeName="XBA";
			XBA();
			break;
		//exchange CARRY and EMULATION flags
		//this is the way to enter/exit 6502 emulation mode
		case 0xfb:
			opcodeName="XCE";
			XCE();
			break;
		//if we get here we're probably in invalid or uninitialized memory
		default:
			fault("Unrecognized opcode in execution: "+opcode);
			break;
		}
	}
	
	//determine how many cycles based on the instruction
/*	private int cycledelay()
	{
		switch(opcode)
		{	
		case 0x54: case 0x44:
			return (3); 
		case 0x69: case 0x2d: case 0x0a: case 0x90: case 0xb0: case 0xf0: case 0x89: case 0x30: case 0xd0: case 0x10: case 0x50: case 0x70: case 0x58: case 0xb8: case 0x18: case 0xd8: case 0xc9: case 0xe0: case 0xc0: case 0x3a: case 0xca: case 0x88: case 0x49: case 0x1a: case 0xe8: case 0xc8: case 0xa9: case 0xa2: case 0xa0: case 0x4a: case 0xea: case 0x09: case 0x2a: case 0x6a: case 0xe9: case 0x38: case 0xf8: case 0x78: case 0xaa: case 0xa8: case 0x5b: case 0x1b: case 0x7b: case 0x3b: case 0xba: case 0x8a: case 0x9a: case 0x9b: case 0x98: case 0xbb: case 0xfb:
			return (2); 
		case 0x65: case 0x25: case 0x24: case 0x80: case 0xc5: case 0xe4: case 0xc4: case 0x45: case 0x4c: case 0xa5: case 0xa6: case 0xa4: case 0x05: case 0x48: case 0x8b: case 0x4b: case 0x08: case 0xda: case 0x5a: case 0xc2: case 0xe5: case 0xe2: case 0x85: case 0xdb: case 0x86: case 0x84: case 0x64: case 0xcb: case 0xeb:
			return (3); 
		case 0x63: case 0x6d: case 0x75: case 0x79: case 0x7d: case 0x23: case 0x29: case 0x35: case 0x39: case 0x3d: case 0x2c: case 0x34: case 0x3c: case 0x82: case 0xc3: case 0xcd: case 0xd5: case 0xd9: case 0xdd: case 0xec: case 0xcc: case 0x43: case 0x4d: case 0x55: case 0x59: case 0x5d: case 0x5c: case 0xa3: case 0xad: case 0xb5: case 0xb9: case 0xbd: case 0xae: case 0xb6: case 0xbe: case 0xac: case 0xb4: case 0xbc: case 0x03: case 0x0d: case 0x15: case 0x19: case 0x1d: case 0x0b: case 0x68: case 0xab: case 0x28: case 0xfa: case 0x7a: case 0xe3: case 0xed: case 0xf5: case 0xf9: case 0xfd: case 0x83: case 0x8d: case 0x95: case 0x8e: case 0x96: case 0x8c: case 0x94: case 0x74: case 0x9c:
			return (4); 
		case 0x6f: case 0x71: case 0x72: case 0x7f: case 0x2f: case 0x31: case 0x32: case 0x3f: case 0x06: case 0xcf: case 0xd1: case 0xd2: case 0xdf: case 0xc6: case 0x4f: case 0x51: case 0x52: case 0x5f: case 0xe6: case 0x6c: case 0xaf: case 0xb1: case 0xb2: case 0xbf: case 0x0f: case 0x11: case 0x12: case 0x1f: case 0xf4: case 0x2b: case 0x26: case 0x66: case 0xef: case 0xf1: case 0xf2: case 0xff: case 0x8f: case 0x92: case 0x99: case 0x9d: case 0x9f: case 0x9e: case 0x14: case 0x04: case 0x46:
			return (5); 
		case 0x61: case 0x67: case 0x77: case 0x21: case 0x27: case 0x37: case 0x0e: case 0x16: case 0xc1: case 0xc7: case 0xd7: case 0xce: case 0xd6: case 0x41: case 0x47: case 0x57: case 0xee: case 0xf6: case 0x7c: case 0xdc: case 0x20: case 0xa1: case 0xa7: case 0xb7: case 0x4e: case 0x56: case 0x01: case 0x07: case 0x17: case 0xd4: case 0x62: case 0x2e: case 0x36: case 0x6e: case 0x76: case 0x40: case 0x6b: case 0x60: case 0xe1: case 0xe7: case 0xf7: case 0x81: case 0x87: case 0x91: case 0x97: case 0x1c: case 0x0c:
			return (6); 
		case 0x73: case 0x33: case 0x1e: case 0x00: case 0xd3: case 0x02: case 0xde: case 0x53: case 0xfe: case 0xb3: case 0x5e: case 0x13: case 0x3e: case 0x7e: case 0xf3: case 0x93:
			return (7); 
		case 0x22: case 0xfc:
			return (8); 
		default:
			fault("Unrecognized opcode in cycle count "+opcode);
		}
		return 0;
	}*/
	//cycle delay when memory accesses and fetches are considered separately
	private int cycleDelayMinusMemory()
	{
		switch(opcode)
		{
		case 0x0a: case 0x2a: case 0x3a: case 0x4a: case 0x5a: case 0x6a: case 0x8a: case 0x9a: case 0xaa: case 0xba: case 0xca: case 0xda: case 0xea: case 0xfa:
		case 0x08: case 0x18: case 0x38: case 0x58: case 0x68: case 0x78: case 0x88: case 0x98: case 0xa8: case 0xb8: case 0xc8: case 0xd8: case 0xe8: case 0xf8:
		case 0x0b: case 0x1b: case 0x3b: case 0x4b: case 0x5b: case 0x7b: case 0x8b: case 0x9b: case 0xbb: case 0xfb:
		case 0x20: case 0xc2:
			return 1*6;

		case 0xab: case 0x2b: case 0x28: case 0x6b: case 0x7a: case 0xeb: case 0x40: case 0xcb:
			return 2*6;
			
		case 0x60:
			return 3*6;
		}
		return 0;
	}
	
	private void BCC(int addr)
	{
		if(!CARRY)
		{
			PC=addr;
			if(mode16)
				cycleCount+=(1);
		}
	}
	private void BCS(int addr)
	{
		if(CARRY)
		{
			PC=addr;
			if(mode16)
				cycleCount+=(1);
		}
	}
	private void BEQ(int addr)
	{
		if(ZERO)
		{
			PC=addr;
			if(mode16)
				cycleCount+=(1);
		}
	}
	private void BMI(int addr)
	{
		if(NEGATIVE)
		{
			PC=addr;
			if(mode16)
				cycleCount+=(1);
		}
	}
	private void BPL(int addr)
	{
		if(!NEGATIVE)
		{
			PC=addr;
			if(mode16)
				cycleCount+=(1);
		}
	}
	private void BNE(int addr)
	{
		if(!ZERO)
		{
			PC=addr;
			if(mode16)
				cycleCount+=(1);
		}
	}
	private void BVC(int addr)
	{
		if(!OVERFLOW)
		{
			PC=addr;
			if(mode16)
				cycleCount+=(1);
		}
	}
	private void BVS(int addr)
	{
		if(OVERFLOW)
		{
			PC=addr;
			if(mode16)
				cycleCount+=(1);
		}
	}
	private void BRA(int addr)
	{
		PC=addr;
		if(mode16)
			cycleCount+=(1);
	}
	private void BRL(int addr)
	{
		PC=addr;
	}
	private void ADC16(int value)
	{
		int result;
		if (DECIMAL)
		{
			int A1=A&0xf, A2=A&0xf0, A3=A&0xf00, A4=A&0xf000;
			int V1=value&0xf, V2=value&0xf0, V3=value&0xf00, V4=value&0xf000;
			A1=V1+(CARRY?1:0);
			if (A1>0x9)
			{
				A1=(A1-0xa)&0xf;
				A2+=0x10;
			}
			A2+=V2;
			if (A2>0x90)
			{
				A2=(A2-0xa0)&0xf0;
				A3+=0x100;
			}
			A3+=V3;
			if (A3>0x900)
			{
				A3=(A3-0xa00)&0xf00;
				A4+=0x1000;
			}
			A4+=V4;
			if (A4>0x9000)
			{
				A4=(A4-0xa000)&0xf000;
				CARRY=true;
			}
			else
				CARRY=false;
			result=A4|A3|A2|A1;
		}
		else
		{
//			System.out.printf("%x %x\n",A,value);
			result=A+value+(CARRY?1:0);
			CARRY=(result>=0x10000);
		}
		OVERFLOW= ((~(A^value)&(value^(result&0xffff)) & 0x8000)!=0);
		A=(result&0xffff);
		ZERO= ((A&0xffff)==0);
		NEGATIVE= ((A&0x8000)!=0);
	}
	private void ADC8(int value)
	{
		int result;
		if (DECIMAL)
		{
			int A1=A&0xf, A2=A&0xf0;
			int V1=value&0xf, V2=value&0xf0;
			A1=V1+(CARRY?1:0);
			if (A1>0x9)
			{
				A1=(A1-0xa)&0xf;
				A2+=0x10;
			}
			A2+=V2;
			if (A2>0x90)
			{
				A2=(A2-0xa0)&0xf0;
				CARRY=true;
			}
			else
				CARRY=false;
			result=A2|A1;
		}
		else
		{
//			System.out.printf("8 %x %x\n",A,value);
			result=(A&0xff)+value+(CARRY?1:0);
			CARRY=(result>=0x100);
			OVERFLOW= ((~((A&0xff)^value)&(value^(result&0xff)) & 0x80)!=0);
		}
		A=(A&(~0xff))|(result&0xff);
		ZERO= ((A&0xff)==0);
		NEGATIVE= ((A&0x80)!=0);
	}
	private void AND16(int value)
	{
		A=A&(value&0xffff);
		ZERO= ((A&0xffff)==0);
		NEGATIVE= ((A&0x8000)!=0);
	}
	private void AND8(int value)
	{
		int result=A&value;
		A=(A&(~0xff))|(result&0xff);
		ZERO= ((A&0xff)==0);
		NEGATIVE= ((A&0x80)!=0);
	}
	private void OR16(int value)
	{
		A=A|(value&0xffff);
		ZERO= ((A&0xffff)==0);
		NEGATIVE= ((A&0x8000)!=0);
	}
	private void OR8(int value)
	{
		int result=A|value;
		A=(A&(~0xff))|(result&0xff);
		ZERO= ((A&0xff)==0);
		NEGATIVE= ((A&0x80)!=0);
	}
	private int ASL16(int value)
	{
		int result=value&0xffff;
		CARRY=((result&0x8000)!=0);
		result=result<<1;
		ZERO= ((result&0xffff)==0);
		NEGATIVE= ((result&0x8000)!=0);
		return (result&0xffff);
	}
	private int ASL8(int value)
	{
		int result=value&0xff;
		CARRY=((result&0x80)!=0);
		result=result<<1;
		ZERO= ((result&0xff)==0);
		NEGATIVE= ((result&0x80)!=0);
		return (result&0xff);
	}
	private void BIT8(int value)
	{
		value=value&0xff;
		int result=(value&0xff)&(A&0xff);
		OVERFLOW=((value&0x40)!=0);
		NEGATIVE= ((value&0x80)!=0);
		ZERO= (result==0);
	}
	private void BIT16(int value)
	{
		value=value&0xffff;
		int result=(value&0xffff)&(A&0xffff);
		OVERFLOW=((value&0x4000)!=0);
		NEGATIVE= ((value&0x8000)!=0);
		ZERO= (result==0);
	}
	private void CMP16(int value)
	{
		int result=A-value;
		CARRY=(result>=0);
		ZERO= ((result&0xffff)==0);
		NEGATIVE= ((result&0x8000)!=0);
	}
	private void CMP8(int value)
	{
		int result=(A&0xff)-(value&0xff);
		CARRY=(result>=0);
		ZERO= ((result&0xff)==0);
		NEGATIVE= ((result&0x80)!=0);
	}
	private void CPX16(int value)
	{
		int result=X-(value&0xffff);
		CARRY=(result>=0);
		ZERO= ((result&0xffff)==0);
		NEGATIVE= ((result&0x8000)!=0);
	}
	private void CPX8(int value)
	{
		int result=(X&0xff)-(value&0xff);
		CARRY=(result>=0);
		ZERO= ((result&0xff)==0);
		NEGATIVE= ((result&0x80)!=0);
	}
	private void CPY16(int value)
	{
		int result=Y-value;
		CARRY=(result>=0);
		ZERO= ((result&0xffff)==0);
		NEGATIVE= ((result&0x8000)!=0);
	}
	private void CPY8(int value)
	{
		int result=(Y&0xff)-(value&0xff);
		CARRY=(result>=0);
		ZERO= ((result&0xff)==0);
		NEGATIVE= ((result&0x80)!=0);
	}
	private int DEC16(int value)
	{
		int result=value&0xffff;
		result=result-1;
		ZERO= ((result&0xffff)==0);
		NEGATIVE= ((result&0x8000)!=0);
		return (result&0xffff);
	}
	private int DEC8(int value)
	{
		int result=value&0xff;
		result=result-1;
		ZERO= ((result&0xff)==0);
		NEGATIVE= ((result&0x80)!=0);
		return (result&0xff);
	}
	private void DEA16()
	{
		A=(A-1)&0xffff;
		ZERO= ((A&0xffff)==0);
		NEGATIVE= ((A&0x8000)!=0);
	}
	private void DEA8()
	{
		A=(A&(~0xff))|((A-1)&0xff);
		ZERO= ((A&0xff)==0);
		NEGATIVE= ((A&0x80)!=0);
	}
	private void DEX16()
	{
		X=(X-1)&0xffff;
		ZERO= ((X&0xffff)==0);
		NEGATIVE= ((X&0x8000)!=0);
	}
	private void DEX8()
	{
		X=(X-1)&0xff;
		ZERO= ((X&0xff)==0);
		NEGATIVE= ((X&0x80)!=0);
	}
	private void DEY16()
	{
		Y=(Y-1)&0xffff;
		ZERO= ((Y&0xffff)==0);
		NEGATIVE= ((Y&0x8000)!=0);
	}
	private void DEY8()
	{
		Y=(Y-1)&0xff;
		ZERO= ((Y&0xff)==0);
		NEGATIVE= ((Y&0x80)!=0);
	}
	private void EOR16(int value)
	{
		A=A^(value&0xffff);
		ZERO= ((A&0xffff)==0);
		NEGATIVE= ((A&0x8000)!=0);
	}
	private void EOR8(int value)
	{
		int result=A^value;
		A=(A&(~0xff))|(result&0xff);
		ZERO= ((A&0xff)==0);
		NEGATIVE= ((A&0x80)!=0);
	}
	private int INC16(int value)
	{
		int result=value&0xffff;
		result=result+1;
		ZERO= ((result&0xffff)==0);
		NEGATIVE= ((result&0x8000)!=0);
		return (result&0xffff);
	}
	private int INC8(int value)
	{
		int result=value&0xff;
		result=result+1;
		ZERO= ((result&0xff)==0);
		NEGATIVE= ((result&0x80)!=0);
		return (result&0xff);
	}
	private void INA16()
	{
		A=(A+1)&0xffff;
		ZERO= ((A&0xffff)==0);
		NEGATIVE= ((A&0x8000)!=0);
	}
	private void INA8()
	{
		A=(A&(~0xff))|((A+1)&0xff);
		ZERO= ((A&0xff)==0);
		NEGATIVE= ((A&0x80)!=0);
	}
	private void INX16()
	{
		X=(X+1)&0xffff;
		ZERO= ((X&0xffff)==0);
		NEGATIVE= ((X&0x8000)!=0);
	}
	private void INX8()
	{
		X=(X+1)&0xff;
		ZERO= ((X&0xff)==0);
		NEGATIVE= ((X&0x80)!=0);
	}
	private void INY16()
	{
		Y=(Y+1)&0xffff;
		ZERO= ((Y&0xffff)==0);
		NEGATIVE= ((Y&0x8000)!=0);
	}
	private void INY8()
	{
		Y=(Y+1)&0xff;
		ZERO= ((Y&0xff)==0);
		NEGATIVE= ((Y&0x80)!=0);
	}
	private void LDA16(int value)
	{
		A=value&0xffff;
		ZERO= ((A&0xffff)==0);
		NEGATIVE= ((A&0x8000)!=0);
	}
	private void LDA8(int value)
	{
		A=(A&(~0xff))|(value&0xff);
		ZERO= ((A&0xff)==0);
		NEGATIVE= ((A&0x80)!=0);
	}
	private void LDX16(int value)
	{
		X=value&0xffff;
		ZERO= ((X&0xffff)==0);
		NEGATIVE= ((X&0x8000)!=0);
	}
	private void LDX8(int value)
	{
		X=(X&(~0xff))|(value&0xff);
		ZERO= ((X&0xff)==0);
		NEGATIVE= ((X&0x80)!=0);
	}
	private void LDY16(int value)
	{
		Y=value&0xffff;
		ZERO= ((Y&0xffff)==0);
		NEGATIVE= ((Y&0x8000)!=0);
	}
	private void LDY8(int value)
	{
		Y=(Y&(~0xff))|(value&0xff);
		ZERO= ((Y&0xff)==0);
		NEGATIVE= ((Y&0x80)!=0);
	}
	private int LSR16(int value)
	{
		int result=value&0xffff;
		CARRY=((result&1)!=0);
		result=result>>1;
		ZERO= ((result&0xffff)==0);
		NEGATIVE= ((result&0x8000)!=0);
		return (result&0xffff);
	}
	private int LSR8(int value)
	{
		int result=value&0xff;
		CARRY=((result&1)!=0);
		result=result>>1;
		ZERO= ((result&0xff)==0);
		NEGATIVE= ((result&0x80)!=0);
		return (result&0xff);
	}
	private int ROR16(int value)
	{
		int result=value&0xffff;
		if(CARRY)
			result+=0x10000;
		CARRY=((result&1)!=0);
		result=result>>1;
		ZERO= ((result&0xffff)==0);
		NEGATIVE= ((result&0x8000)!=0);
		return (result&0xffff);
	}
	private int ROR8(int value)
	{
		int result=value&0xff;
		if (CARRY)
			result+=0x100;
		CARRY=((result&1)!=0);
		result=result>>1;
		ZERO= ((result&0xff)==0);
		NEGATIVE= ((result&0x80)!=0);
		return (result&0xff);
	}
	private int ROL16(int value)
	{
		int result=value&0xffff;
		result=result<<1;
		if(CARRY)
			result+=1;
		CARRY=((result&0x10000)!=0);
		ZERO= ((result&0xffff)==0);
		NEGATIVE= ((result&0x8000)!=0);
		return (result&0xffff);
	}
	private int ROL8(int value)
	{
		int result=value&0xff;
		result=result<<1;
		if(CARRY)
			result+=1;
		CARRY=((result&0x100)!=0);
		ZERO= ((result&0xff)==0);
		NEGATIVE= ((result&0x80)!=0);
		return (result&0xff);
	}
	private void SBC16(int value)
	{
		value=value&0xffff;
		int result;
		if(DECIMAL)
		{
			int A1=A&0xf, A2=A&0xf0, A3=A&0xf00, A4=A&0xf000;
			int V1=value&0xf, V2=value&0xf0, V3=value&0xf00, V4=value&0xf000;
			A1-=V1+(CARRY?0:1);
			A2-=V2;
			A3-=V3;
			A4-=V4;
			if (A1>=0xf)
			{
				A1=(A1+0xa)&0xf;
				A2-=0x10;
			}
			if (A2>=0xf0)
			{
				A2=(A2+0xa0)&0xf0;
				A3-=0x100;
			}
			if (A3>=0xf00)
			{
				A3=(A3+0xa00)&0xf00;
				A4-=0x1000;
			}
			if (A4>=0xf000)
			{
				A4=(A4+0xa000)&0xf000;
				CARRY=false;
			}
			else
				CARRY=true;
			result=A4|A3|A2|A1;
		}
		else
		{
			result=A-value+(CARRY?1:0)-1;
			CARRY=(result>=0);
			OVERFLOW= (((A^value)&(A^(result&0xffff)) & 0x8000)!=0);
		}
		A=(result&0xffff);
		ZERO= ((A&0xffff)==0);
		NEGATIVE= ((A&0x8000)!=0);
	}
	private void SBC8(int value)
	{
		value=value&0xff;
		int result;
		if(DECIMAL)
		{
			int A1=A&0xf, A2=A&0xf0;
			int V1=value&0xf, V2=value&0xf0;
			A1-=V1+(CARRY?0:1);
			A2-=V2;
			if (A1>=0xf)
			{
				A1=(A1+0xa)&0xf;
				A2-=0x10;
			}
			if (A2>=0xf0)
			{
				A2=(A2+0xa0)&0xf0;
				CARRY=false;
			}
			else
				CARRY=true;
			result=A2|A1;
		}
		else
		{
			result=(A&0xff)-value+(CARRY?1:0)-1;
			CARRY=(result>=0);
			OVERFLOW= ((((A&0xff)^value)&(A^(result&0xff)) & 0x80)!=0);
		}
		A=(A&(~0xff))|(result&0xff);
		ZERO= ((A&0xff)==0);
		NEGATIVE= ((A&0x80)!=0);
	}
	private int STA16()
	{
		return A&0xffff;
	}
	private int STA8()
	{
		return A&0xff;
	}
	private int STX16()
	{
		return X&0xffff;
	}
	private int STX8()
	{
		return X&0xff;
	}
	private int STY16()
	{
		return Y&0xffff;
	}
	private int STY8()
	{
		return Y&0xff;
	}
	private int STZ()
	{
		return 0;
	}
	private int TSB16(int value)
	{
		ZERO=((value&A)==0);
		value=value|A;
		return (value&0xffff);
	}
	private int TSB8(int value)
	{
		ZERO=((value&(A&0xff))==0);
		value=value|(A&0xff);
		return (value&0xff);
	}
	private int TRB16(int value)
	{
		ZERO=((value&A)==0);
		value=value&~A;
		return (value&0xffff);
	}
	private int TRB8(int value)
	{
		ZERO=((value&(A&0xff))==0);
		value=value&~(A&0xff);
		return (value&0xff);
	}
	private void TAX()
	{
		if(X16)
		{
			X=A;
			ZERO= ((X&0xffff)==0);
			NEGATIVE= ((X&0x8000)!=0);
		}
		else
		{
			X=(X&~0xff)|(A&0xff);
			ZERO= ((X&0xff)==0);
			NEGATIVE= ((X&0x80)!=0);
		}
	}
	private void TAY()
	{
		if(X16)
		{
			Y=A;
			ZERO= ((Y&0xffff)==0);
			NEGATIVE= ((Y&0x8000)!=0);
		}
		else
		{
			Y=(Y&~0xff)|(A&0xff);
			ZERO= ((Y&0xff)==0);
			NEGATIVE= ((Y&0x80)!=0);
		}
	}
	private void TXA()
	{
		if(mode16)
		{
			A=X;
			ZERO= ((A&0xffff)==0);
			NEGATIVE= ((A&0x8000)!=0);
		}
		else
		{
			A=(A&~0xff)|(X&0xff);
			ZERO= ((A&0xff)==0);
			NEGATIVE= ((A&0x80)!=0);
		}
	}
	private void TYA()
	{
		if(mode16)
		{
			A=Y;
			ZERO= ((A&0xffff)==0);
			NEGATIVE= ((A&0x8000)!=0);
		}
		else
		{
			A=(A&~0xff)|(Y&0xff);
			ZERO= ((A&0xff)==0);
			NEGATIVE= ((A&0x80)!=0);
		}
	}
	private void TSX()
	{
		if(X16)
		{
			X=S;
			ZERO= ((X&0xffff)==0);
			NEGATIVE= ((X&0x8000)!=0);
		}
		else
		{
			X=(X&~0xff)|(S&0xff);
			ZERO= ((X&0xff)==0);
			NEGATIVE= ((X&0x80)!=0);
		}
	}
	private void TXS()
	{
		S=X;
		if(EMULATION)
			S=0x100|(S&0xff);
	}
	private void TYX()
	{
		if(X16)
		{
			X=Y;
			ZERO= ((X&0xffff)==0);
			NEGATIVE= ((X&0x8000)!=0);
		}
		else
		{
			X=(X&~0xff)|(Y&0xff);
			ZERO= ((X&0xff)==0);
			NEGATIVE= ((X&0x80)!=0);
		}
	}
	private void TXY()
	{
		if(X16)
		{
			Y=X;
			ZERO= ((Y&0xffff)==0);
			NEGATIVE= ((Y&0x8000)!=0);
		}
		else
		{
			Y=(Y&~0xff)|(X&0xff);
			ZERO= ((Y&0xff)==0);
			NEGATIVE= ((Y&0x80)!=0);
		}
	}

	private void TSC()
	{
		A=S;
		ZERO= ((A&0xffff)==0);
		NEGATIVE= ((A&0x8000)!=0);
	}
	private void TCS()
	{
		S=A;
		if(EMULATION)
			S=0x100|(S&0xff);
	}
	private void TCD()
	{
		D=A;
		ZERO= ((D&0xffff)==0);
		NEGATIVE= ((D&0x8000)!=0);
	}
	private void TDC()
	{
		A=D;
		ZERO= ((A&0xffff)==0);
		NEGATIVE= ((A&0x8000)!=0);
	}
	private void XBA()
	{
		int tmp=(A>>8)&0xff;
		A=(A<<8)&0xff00;
		A=A|tmp;
		ZERO= ((A&0xff)==0);
		NEGATIVE= ((A&0x80)!=0);
	}
	private void XCE()
	{
		boolean tmp=CARRY;
		CARRY=EMULATION;
		EMULATION=tmp;
		if(EMULATION)
		{
			INDEXFLAG=true;
			MEMORYFLAG=true;
			S=0x100|(S&0xff);
		}
		if(INDEXFLAG)
		{
			X&=0xff;
			Y&=0xff;
		}

	}
	private void COP()
	{
		updateP();
		if(!EMULATION)
		{
			PUSHB16(PBR);
			PUSHW16((PC+1)&0xffff);
			PUSHB16(P&0xff);
		}
		else
		{
			PUSHW8((PC+1)&0xffff);
			PUSHB8(P&0xff);
		}
		DECIMAL=false;
		IRQ=true;
		PC=(snes.memory.readByte(0xfff4)&0xff)|((snes.memory.readByte(0xfff5)<<8)&0xff00);
	}
	
	//on a non-maskable interrupt, push the PBR, PC, flags and jump to the service routine
	public void NMI()
	{
		updateP();
		if(!EMULATION)
		{
			PUSHB16(PBR);
			PUSHW16(PC);
			PUSHB16(P&0xff);
			DECIMAL=false;
			IRQ=true;
			PC=(snes.memory.readByte(0xffea)&0xff)|((snes.memory.readByte(0xffeb)<<8)&0xff00);
			PBR=0;
		}
		else
		{
			PUSHW8(PC);
			PUSHB8(P&0xff);
			DECIMAL=false;
			IRQ=true;
			PC=(snes.memory.readByte(0xfffa)&0xff)|((snes.memory.readByte(0xfffb)<<8)&0xff00);
		}
	}

	//on an IRQ, push flags, PC, PBR, jump to service routine
	public void IRQ()
	{
		updateP();
		if(!EMULATION)
		{
			PUSHB16(PBR);
			PUSHW16(PC);
			PUSHB16(P&0xff);
			DECIMAL=false;
			IRQ=true;
			PC=(snes.memory.readByte(0xffee)&0xff)|((snes.memory.readByte(0xffef)<<8)&0xff00);
			PBR=0;
		}
		else
		{
			PUSHW8(PC);
			PUSHB8(P&0xff);
			DECIMAL=false;
			IRQ=true;
			PC=(snes.memory.readByte(0xfffe)&0xff)|((snes.memory.readByte(0xffff)<<8)&0xff00);
		}
	}

	//on a break, push PBR, PC, flags, jump to service routine
	public void BRK()
	{
		updateP();
		if(!EMULATION)
		{
			PUSHB16(PBR);
			PUSHW16((PC+1)&0xffff);
			PUSHB16(P&0xff);
			DECIMAL=false;
			IRQ=true;
			PC=(snes.memory.readByte(0xffe6)&0xff)|((snes.memory.readByte(0xffe7)<<8)&0xff00);
			PBR=0;
		}
		else
		{
			PUSHW8((PC+1)&0xffff);
			PUSHB8(P&0xff);
			DECIMAL=false;
			IRQ=true;
			PC=(snes.memory.readByte(0xfffe)&0xff)|((snes.memory.readByte(0xffff)<<8)&0xff00);
		}
//		waitForInterrupt=true;
	}
	
	//push to stack
	private void PUSHW16(int word)
	{
		int low=word&0xff;
		int high=(word>>8)&0xff;
		snes.memory.writeByte((S-1)&0xffff, (byte)low);
		snes.memory.writeByte(S, (byte)high);
		S=(S-2)&0xffff;
	}
	private void PUSHW8(int word)
	{
		int low=word&0xff;
		int high=(word>>8)&0xff;
		S=(S&0xff00)|((S-1)&0xff);
		snes.memory.writeByte(S, (byte)low);
		snes.memory.writeByte((S+1)&0xffff, (byte)high);
		S=(S&0xff00)|((S-1)&0xff);
	}
	private void PUSHB16(int b)
	{
		b=b&0xff;
		snes.memory.writeByte(S, (byte)b);
		S=(S-1)&0xffff;
	}
	private void PUSHB8(int b)
	{
		b=b&0xff;
		snes.memory.writeByte(S, (byte)b);		
		S=(S&0xff00)|((S-1)&0xff);
	}
	
	//pop from stack
	private int PULLW16()
	{
		int low=snes.memory.readByte((S+1)&0xffff)&0xff;
		int high=snes.memory.readByte((S+2)&0xffff)&0xff;
		S=(S+2)&0xffff;
		return (high<<8)|low;
	}
	private int PULLB16()
	{
		S=(S+1)&0xffff;
		int low=snes.memory.readByte(S)&0xff;
		return low;
	}
    private int PULLW8()
	{
		S=(S&0xff00)|((S+1)&0xff);
		int low=snes.memory.readByte(S)&0xff;
		int high=snes.memory.readByte((S+1)&0xffff)&0xff;
		S=(S&0xff00)|((S+1)&0xff);
//		return high*256+low;		
		return (high<<8)|low;
	}
	private int PULLB8()
	{
		S=(S&0xff00)|((S+1)&0xff);
		int low=snes.memory.readByte(S)&0xff;
		return low;	
	}
	//set the P register using the flags
	public void updateP()
	{
		P=0;
		if(CARRY) P|=CARRYBIT;
		if(ZERO) P|=ZEROBIT;
		if(IRQ) P|=IRQBIT;
		if(DECIMAL) P|=DECIMALBIT;
		if(INDEXFLAG) P|=INDEXFLAGBIT;
		if(MEMORYFLAG) P|=MEMORYFLAGBIT;
		if(OVERFLOW) P|=OVERFLOWBIT;
		if(NEGATIVE) P|=NEGATIVEBIT;
		if(EMULATION) P|=EMULATIONBIT;
	}
	//set flags according to the value in P
	public void updateFlagsFromP()
	{
		CARRY=(P&CARRYBIT)!=0;
		ZERO=(P&ZEROBIT)!=0;
		IRQ=(P&IRQBIT)!=0;
		DECIMAL=(P&DECIMALBIT)!=0;
		INDEXFLAG=(P&INDEXFLAGBIT)!=0;
		MEMORYFLAG=(P&MEMORYFLAGBIT)!=0;
		OVERFLOW=(P&OVERFLOWBIT)!=0;
		NEGATIVE=(P&NEGATIVEBIT)!=0;
		EMULATION=(P&EMULATIONBIT)!=0;
	}
	
	//an invalid instruction byte was encountered
	private void fault(String message)
	{
		System.out.println(message);
//		System.exit(0);
	}
	
	//dump all regs to a debugging trace file
	public void printState()
	{
		updateP();
		snes.snesgui.cputrace.printf("ICount %d Cycle %d Inst: %s Opcode %x PBR: %x PC: %x DBR: %x D: %x A: %x X: %x Y: %x S: %x P: %x\n", instructionCount,cycleCount,opcodeName,opcode,PBR,PC,DBR,D,A,X,Y,S,P);
//		snes.snesgui.cputrace.printf("ICount %d Inst %x PBR: %x PC: %x DBR: %x D: %x A: %x X: %x Y: %x S: %x P: %x\n", instructionCount,opcode,PBR,PC,DBR,D,A,X,Y,S,P);
//		snes.snesgui.cputrace.printf("%d %x %x %x %x %x %x %x %x %x %x\n", instructionCount,PBR,PC,DBR,D,A,X,Y,S,P,snes.ppu.VCounter);
	}
	
	//save processor state to a snapshot string
	public String dumpProcessorState()
	{
		updateP();
		String ret="processor\n";
		ret+=String.format("%x %x %x %x %x %x %x %x %x ",A,X,Y,S,D,P,PC,PBR,DBR);
		ret+=String.format("%d %d ",NMItriggerPosition,instructionsUntilEvent);
		ret+=instructionCount+" "+cycleCount+" ";
		ret+=String.format("%x %x ",waitForInterrupt?1:0,NMItrigger?1:0);
		ret+="\n";
		return ret;
	}
	//load processor state from a snapshot string
	public void loadProcessorState(String state)
	{
		Scanner s=new Scanner(state);
		A=s.nextInt(16); X=s.nextInt(16); Y=s.nextInt(16); S=s.nextInt(16); D=s.nextInt(16); P=s.nextInt(16); PC=s.nextInt(16); PBR=s.nextInt(16); DBR=s.nextInt(16);
		NMItriggerPosition=s.nextInt(); instructionsUntilEvent=s.nextInt(); instructionCount=s.nextLong(); cycleCount=s.nextLong();
		waitForInterrupt=s.nextInt()==1; NMItrigger=s.nextInt()==1;
		updateFlagsFromP();
	}
}
